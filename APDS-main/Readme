This is our APDS7312 Final POE

Github
https://github.com/RubenJvR/APDS

Sonar Qube
https://sonarcloud.io/summary/overall?id=RubenJvR_APDS&branch=main

demo video:
https://youtu.be/QuYmV2gTeYo

To run the system open the folder \APDS-main\BACKEND> and enter: npm run start 
It may request the user to install express-mongo-sanitize, to do so run: npm install express-mongo-sanitize
this will start the backend server

open the folder \APDS-main\FRONTEND\frontend in a different terminal and enter: npm start
It may not recognize react therefore the user would have to run the following: npm install
this will launch the frontend. 

The browser may warn the user about the application, they will have to click on show more and proceed to the website

Features list:

-- Login
        There is the login page where users can login as either an admin or user

        admin credentials:
        Username: admi
        account number: 00111011101
        password: Adminpass1

        user credentials
        Username: finUser
        account number: 999999999
        password: A12fe34dc56

-- Transfer
        users can transfer funds by entering another user's account number and ammount 
        of money on the transfer funds page. These transfers are pending, but can be approved by an admin.
-- Add Funds
        users can also add funds on the Add Funds page

-- Admin pages
        Admins can approve or disprove pending payments and see a list of all users, these pages are only visible to admins

All traffic is served over SSL
And https connections are over both the front and backend
The system uses Regex to process all user inputs
There is password hashing and salting using bcrypt

Attack prevention:

-- Session jacking
        I created a session hijacking prevention system that uses JWT-based authentication along with several security measures to protect user accounts and sessions.

        How it works:
        When a user logs in, the system generates a JSON Web Token (JWT) that contains the user’s name and account number, a unique session ID (jti) to prevent session fixation attacks, and the user’s IP address and user agent string to detect unusual activity. The token is signed with a secret key and set to expire in 30 minutes, which limits the lifespan of any potentially compromised tokens. It’s then sent back to the client as a secure, HTTP-only cookie, which helps prevent scripts from accessing it on the client side.

        For authentication, all protected routes use a checkAuth middleware that verifies the JWT before granting access. The middleware reads the JWT from a secure cookie (or from the authorisation header as a fallback), decodes and verifies it using the secret key, and checks that the IP address and user agent match the ones stored in the token. If the token is missing, expired, or invalid, or if the IP or user agent doesn’t match, the request is rejected with a 401 Unauthorised response. If everything checks out, the middleware attaches the decoded user information to req.user so other route handlers can use it.

        This setup ensures that even if someone manages to steal a JWT, they can’t use it from a different IP address or device. By combining short-lived JWTs, IP and user agent validation, and rate limiting, the system significantly reduces the chances of session hijacking or unauthorised account access.

-- MIM
        The two precautions taken against Man in the middle attacks in this application reside within these two defences.
        •	HTTPS: Which secures the connection of the user portal 
        •	Helmet — secures all http headers used during user and payment transactions 

        Https- Protection on the network level 
        import https from "https";
        import fs from "fs";

        const options = {
        key: fs.readFileSync("keys/mongodb-key.pem"),
        cert: fs.readFileSync("keys/mongodb-cert.pem")
        };

        https.createServer(options, app).listen(3000);
        The above portion of code seeks to encrypt data as a means of preventing attacks from third parties. In addition to this the code also authenticates the server to ensure clients know they have not been lead to a false site connection. With these features in hand the TLS connection will break should any of the connection data be modified but outside parties.

        Helmet- blocks attacks on an application and browser level
        import helmet from "helmet";
        app.use(helmet());

        Helmet provides the network with strict security headers. This ensures that should an attacker manage to intercept the requests that they wont be able to exploit the browser. These attacks are blocked by features meant to protect the browser level such as :
        Strict-Transport-Security: Which forces the browser to use  HTTPS blocking SSL stripping and preventing downgrades to http.
        Content-Security-Policy: Prevents problematic injection of script 
        X-Content-Type-Options: Prevents file-type spoofing

-- DDoS 
        For DDoS prevention we used a rate limiter from the express-rate-limit package
        which checks the amount of requests made by an IP on a window and if it exceeds a certain amount it will block that IP
        const limiter = rateLimit({
            windowMs: 5 * 60 * 1000, 
            max: 100,
            message: 'Too many attempts, please try again later'
        });

        const limiterSignup = rateLimit({
            windowMs: 15 * 60 * 1000, 
            max: 10,
            message: 'Too many sign up attempts, please try again later'
        });
        Here we can see the rate limiting code, the one limit is a 100 in 5 minutes, and the other is 10 in 15 minutes

        we also have this which makes it so that a user can not send a request that is greater than 10 kb in the json format
        app.use(express.json({ limit: "10kb" }));

# XSS Prevention — Summary

**Purpose**

I added a server-side XSS prevention system to sanitize and safely handle user-supplied strings (e.g., signup fields) so we don’t store or reflect HTML/script content.

**How it works**

* A `clean()` helper uses `sanitize-html` (`allowedTags: [], allowedAttributes: {}`) to strip tags/attributes from string inputs.
* Sanitization runs **before** validation and before saving to the database.
* Regex validation runs on sanitized values.
* Responses avoid echoing raw user input — we return only safe fields or IDs.

**Testing with Postman**

Use **Postman** to send a `POST` request to your signup route:

```
POST https://localhost:3000/user/signup
Content-Type: application/json

{
  "fullName": "Hacker <script>alert('XSS')</script>",
  "idNumber": "123456789",
  "accountNumber": "12345678",
  "name": "testuser",
  "password": "TestPass123"
}
```

**Expected:**

* Request returns `201` (user created) or `400` if validation fails.
* No script tags or event attributes appear in stored data.

**Notes / recommendations**

* Move JWT secret to `process.env.JWT_SECRET`.
* Apply `clean()` to other routes that accept free-form input (posts, comments, profile updates).
* Add automated tests that POST malicious payloads and confirm the DB only stores sanitized strings.

---

**Summary for teammates**

I created an XSS prevention system that sanitizes user inputs before validation and storage. Testing can be done directly through **Postman**, ensuring any `<script>` or `onerror` payloads are cleaned or rejected. The signup flow now validates safe inputs, and the DB never stores HTML or script content.


-- Clickjacking

        Clickjacking is a type of attack where users are deceived into clicking hidden or disguised elements on a webpage, leading to unintended actions.
        To mitigate this, the project implements Helmet’s frameguard middleware, which applies the X-Frame-Options: DENY header. This prevents the site from being embedded in external <iframe> elements, protecting users from malicious interface overlays.

        import helmet from "helmet";
        app.use(helmet.frameguard({ action: "deny" }));

        SQL/NoSQL Injection occurs when attackers inject malicious queries through user input to gain unauthorized access or manipulate the database.
        This project utilizes Mongoose ORM along with express-mongo-sanitize to defend against such attacks. User inputs are sanitized and validated before database interaction, removing potentially harmful operators like $ and ..

        import mongoSanitize from "express-mongo-sanitize";
        app.use(mongoSanitize());

-- SQL/NoSQL

        SQL/NoSQL Injection occurs when attackers inject malicious queries through user input to gain unauthorized access or manipulate the database.
        This project utilizes Mongoose ORM along with express-mongo-sanitize to defend against such attacks. User inputs are sanitized and validated before database interaction, removing potentially harmful operators like $ and ..

        import mongoSanitize from "express-mongo-sanitize";
        app.use(mongoSanitize());
        
